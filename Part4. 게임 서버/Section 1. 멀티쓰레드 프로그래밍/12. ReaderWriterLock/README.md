# Section 1.12 ReaderWriterLock

## 지금까지 배운 락 기법에 대한 복습


락을 구현하는 방법론에는 크게 세가지가 있다.

- 무작정 대기하기
- 일단 쉬고 추후에 다시 시도하기
- 다른 사람에게 부탁하여 락을 얻을 때 연락받기

키워드 단위로 본다면 아래와 같이 볼 수 있다. 

- **모니터 기반 lock**

```csharp
static object _lock = new object();

lock (_lock)
{

}
```

- **SpinLock**

```csharp
static SpinLock _lock2 = new SpinLock();

bool lockTaken = false;
try
{
    _lock2.Enter(ref lockTaken);
}
finally
{
    if(lockTaken)
    {
        _lock2.Exit();
    }
}
```

- **Yield 또는 Sleep**

모니터 기반의 락은 대기 큐에 스레드를 등록하고, 해당 스레드가 락을 얻을 수 있을 때까지 블로킹 상태에 돌입하게 된다. 블로킹 상태라 함은 특별한 이벤트가 발생하지 않는다면 무한정 기다리는 상태를 말한다. **(즉, 다른 사람에게 부탁하여 락을 얻을 때 연락받는 방식)**

SpinLock은 **스핀 웨이팅**이라고도 알려진 CPU 실행 권한을 유지하면서 루프를 돌며 대기하는 방식으로 락을 얻는다. 굉장히 비효울적이라고 보이기도 하는 형태이지만 CPU 실행 권한이 스레드로 옮겨 갈때 발생하는 부하(즉, 컨텍스트 스위치)가 없으므로 상황에 따라 굉장히 효율적인 방법이 되기도 한다.

Yield 또는 Sleep은 특정 시간만큼 CPU 실행 권한을 다른 스레드에게 양보하거나 반납하는 형태로 락 획득 시도를 멈추는 것인데, 전체적으로 보면 스핀락의 형태를 가지면서 중간 중간 쉬는 것을 의미한다. 이는 너무 긴 시간동안 스핀 웨이팅을 유지하게 되면 CPU 자원을 크게 소비하므로 마찬가지로 상황에 따라 좋은 방법이 된다. 

C#에서 제공하는 `SpinLock` 클래스는 일정 주기의 스핀 웨이팅으로 락을 얻으려고 시도하지만, 어느정도 시도에도 얻지 못한다면 잠시 쉬는 방식을 선택하기도 한다. 

결과적으로 보면 실제로 사용되는 락 기법들은 여러가지 알려진 기법들을 효율적으로 혼합하여 사용한다. **이는 각 기법들의 장점을 높이고, 단점을 줄이는 방법이다.**

💡 **Mutex**

상호 배제를 제공하기 위한 동기화 메커니즘 중 하나이다. 뮤텍스는 일반적으로 다른 락 기법에 비해 부하가 크다고 알려져 있지만, 다른 락들은 어려운 프로세스 간 동기화를 가능케한다는 장점이 있다. 

게임 서버 입장에서는 다른 프로그램과의 동기화가 필요한 상황이 흔치 않으므로 그렇게 많이 사용되지는 않는 메커니즘이다.


## 읽기 연산과 쓰기 연산의 상호배제 개념


경우에 따라 메모리에 **읽는 연산은 자주 발생하는데, 쓰기 연산은 어쩌다 한번 발생하는 상황**이 발생할 수 있다. 예를 들어, 특정 아이템을 주기적으로 정보 갱신을 해줘야하며, 해당 아이템은 많은 사람들이 자주 메모리에서 읽어서 확인하는 상황이다. 즉 읽기 연산은 많이 발생하지만 쓰기 연산은 가끔만 발생한다. 

스핀락이나 모니터 기반으로 락을 구현한다면 자주 발생하는 읽기 연산에도 락을 얻기 위한 경합이 발생할 것이고 그만큼의 부하가 발생한다. **(쓰기 연산이 발생하지 않는다면 굳이 동기화를 생각할 필요가 없음에도)**

이런 상황을 효율적으로 해결하기 위한 메커니즘으로 ‘**ReaderWriterLock**’이 있다.

읽기와 쓰기 연산을 다르게 다루는 동시성 제어 메커니즘으로 읽기 연산은 여러 스레드에서 동시에 수행이 가능하도록 하여 성능을 향상시키고, 쓰기 연산은 상호 배타적으로 실핸한다. **(쓰기 연산이 진행되는 순간에는 읽기와 쓰기 연산 모두 대기하게 된다)**

```csharp
static ReaderWriterLockSlim _lock3 = new ReaderWriterLockSlim();

_lock3.EnterReadLock();
//메모리 읽기
_lock3.ExitReadLock();

_lock3.EnterWriteLock();
//메모리 쓰기
_lock3.ExitWriteLock();
```

`ReaderWriterLock` 클래스는 이전 버전이다. 굳이 사용하지 않아도 된다.

```
인프런 Rookiss 강사님 로드맵 'C#과 유니티로 만드는 MMORPG 게임 개발 시리즈'에 대한 학습을 진행하면서 작성한 개인 기록용 강의노트입니다.
```
