# Section 1.7 DeadLock 

## DeadLock


두 개 이상의 스레드가 상호 배타적으로 필요한 자원을 가지고 있어, 아무도 진행하지 못하고 무한정 대기 상태에 빠져 있는 현상을 가리킨다. 

상호 배타적 : 두 가지 이상의 것들이 동시에 발생할 수 없는 관계를 나타낸다. 즉, 필요한 자원을 두 사람이 동시에 가지고 있을 수 없는 상황을 말한다.

💡 **자물쇠가 있는 화장실 예시**

화장실을 이용하기 위해 안으로 들어가게 되면 자물쇠를 잠궈 다른 사람이 들어오지 못하게 해야하는데, 만약 안에 있던 사람이 화장실에서 잠들거나 하면 대기 중인 모든 사람들이 화장실을 이용하지 못하게 되는 현상을 데드락으로 볼 수 있다.

실제 프로그래밍 환경에서는 이러한 단순한 상황보다는 두 개 이상의 자물쇠가 있는 상황을 많이 겪는다. 

A 와 B 자물쇠가 있어 두 개를 모두 잠궈야 사용이 가능한 상황에서 어떤 사람이 A을 잠구고 B 자물쇠를 사용하기 위해 대기중이고, 또 다른 사람이 B를 잠구고 A 자물쇠를 사용하기 위해 대기 중일때도 데드락 상황이 발생한다.


프로그래밍 상황에서는 일반적으로 **여러 클래스들에서 각자의 자물쇠를 가지게 되는 경우가 많다.**

### 프로그래밍 상황에서의 lock

두 개의 클래스가 있고 각 자물쇠를 들고 있으며 각 메소드에 따라 자물쇠를 걸어 잠그고 사용해야 하는 경우가 존재한다. 또한, 서로의 기능을 사용해야 하는 있을 때 데드락 상황이 종종 발생한다.

```csharp
class A
{
    static object _lock = new object();

    public static void lockFunc()
    {
        lock (_lock)
        {

        }
    }

    public static void lockFunc2()
    {
        lock (_lock)
        {
            B.lockFunc();
        }
    }
}

class B
{
    static object _lock = new object();
    public static void lockFunc()
    {
        lock (_lock)
        {

        }
    }

    public static void lockFunc2()
    {
        lock (_lock)
        {
            A.lockFunc();   
        }
    }
}
```


💡 **데드락의 예방**

데드락이 발생한 상황에서 선택할 수 있는 기법은 여러 가지가 있지만, 모든 상황을 예측하여 예방하기는 현실적으로 어려운 일이다. 

위와 같은 코드를 똑같게 쓰더라도 어떤 경우에는 데드락이 걸리기도, 안걸리기도 하기 때문이다. 실제 게임 환경에서는 두 스레드가 동일한 시간에 데드락을 유발시킬 수 있는 동작을 해야만 걸리기 때문에 개발 단계과 QA 단계에서 모든 데드락 상황을 통제하는 것은 쉽지 않다.

하나의 예시로 위의 코드를 실행시키는 스레드의 동작 시간을 조금만 떨어트려놔도 데드락은 발생하지 않는다.

```csharp
Task t1 = new Task(Thread_1);
Task t2 = new Task(Thread_2);

t1.Start();

Thread.Sleep(1000);

t2.Start();

Task.WaitAll(t1, t2);
Console.WriteLine(number);
```

```
인프런 Rookiss 강사님 로드맵 'C#과 유니티로 만드는 MMORPG 게임 개발 시리즈'에 대한 학습을 진행하면서 작성한 개인 기록용 강의노트입니다.
```
