# Section 7-2 Interface (인터페이스)
***Date : 2023. 08. 23***
> 가상함수 & 오버라이딩을 통해 메소드를 하위 클래스에 구현하도록 유도할 수 있지만 강제할 수는 없다.   
> 추상화 클래스를 사용하면 하위 클래스에 메소드 구현을 강제할 수 있다. 하지만 다중 상속 문제가 발생할 수 있으며, 이를 해결하기 위해 C#에서는 인터페이스 문법을 제공한다.

### 추상 클래스
- 공통된 코드를 재사용하고 클래스 간의 계층 구조를 정의하는 데 주로 사용된다.
- 기본적으로 클래스이며, 멤버 변수와 메소드를 모두 가질 수 있다.
- abstract 키워드를 사용하여 추상 메소드를 선언하여 하위 클래스에게 해당 메소드의 구현을 강제시킬 수 있다.
- 추상 클래스는 인스턴스를 생성할 수 없다.
- 가상 함수와 오버라이딩과는 달리 강제성의 성격을 가진다.

```C#
    abstract class Monster
    {
        public abstract void shout();
    }

    class Orc : Monster
    {
        public override void shout()  // 반드시 구현해야 한다.
        {
            Console.WriteLine("Shout");
        }
    }
```
---

### 다중 상속
- 여러 클래스를 상속받아 클래스를 구성하는 것을 말한다.
- C++는 지원했으나, '죽음의 다이아몬드 문제'에 의해 C#은 다중 상속을 제한한다.
#### 죽음의 다이아몬드
- 다이아몬드 모양의 상속 구조로 인해 상속 관계가 복잡해지면서 예상치 못한 동작을 일으키는 문제를 일컷는다.
- A,B 클래스가 R 클래스를 상속받아 F 메소드를 오버라이딩하여 작성한 상태일 때, 두 클래스를 모두 상속받은 C 클래스에서 F 메소드를 사용하고자 할 때 어떤 부모 클래스의 메소드를 호출해야 판단하기 어렵다.
- 이러한 문제를 해결하고자 메소드의 선언부만 물려주고 구현부는 물려주지 않는 방식의 문법이 인터페이스이다.

---

### 인터페이스
- 추상적인 계약(Contract)이며, 메소드 시그니처만을 제공하여 하위 클래스에게 구현을 시킨다.
- 클래스는 여러 인터페이스의 다중 상속이 가능하다.
- 클래스에 인터페이스를 상속시키는 것은 인터페이스 기능을 해당 클래스가 가지는 것을 보장하는 개념이다.
```C# 
  interface IFlyable   // 인터페이스 이름의 앞에 I를 붙이는 것이 관습이다.
  {
      void Fly();
  }

  class FlyableOrc : Orc, IFlyable 
  // 기본 클래스 Orc, 인터페이스 IFlyable
  {
      public void Fly()
      {
          Console.WriteLine("Orc Fly");
      }

      public override void shout()
      {
          Console.WriteLine("FlyableOrc Shout!");
      }
  }
```

#### 인터페이스 응용
```C#
  IFlyable flyable = new FlyableOrc();
  // 인터페이스 타입을 상속한 클래스는 해당 인터페이스 타입으로 지정할 수 있다.

  static void DoFly(IFlyable flyable) 
  // 인터페이스를 상속받은 다양한 클래스를 입력으로 받을 수 있다.
  {
      flyable.Fly();
      // 인터페이스를 상속받은 모든 클래스는 .Fly 메소드를 보장하기에
      // 입력으로 들어온 객체에는 .Fly 메소드가 반드시 존재한다.
  }

```







