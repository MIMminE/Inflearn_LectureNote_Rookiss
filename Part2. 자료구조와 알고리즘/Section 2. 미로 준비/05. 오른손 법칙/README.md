# Section 2-4 오른손 법칙
## 우수법(오른손법칙)

오른손으로 벽을 짚으면서 이동하면 언젠가는 목적지로 도달할수 있다의 개념이다. **프로세스 순서는 다음과 같다.**

1. 현재 바라보는 방향을 기준으로 오른쪽으로 갈 수 있는지 확인한다.
    
    갈 수 있다면, 우측 방향으로 90도 회전하여 전진한다.
    
2. 현재 바라보는 방향으로 갈 수 있는지 확인한다. 
    
    갈 수 있다면, 앞으로 전진한다.
    
3. 현재 바라보는 방향에서 좌측 방향으로 90도 회전한다.

### 방향 전환

현재 바라보는 방향을 기준으로 방향을 전환하는 로직은 여러 방법으로 구현이 가능하다.

```csharp
public enum Dir
{
    Up = 0,
    Left = 1,
		Down = 2,
		Right = 3
}

private int _dir = (int)Dir.Up;
```

먼저 현재 바라보는 방향을 기억하기 위한 열거형의 데이터를 생성해준다. 

이후에 생각해볼수 있는 것은 각 방향에 맞춰 **Switch-Case문**을 작성하여 상하좌우에 대한 분기를 구현하는 것이다. 이것은 직관적이기는 하지만 코드가 굉장히 길어질 수 있다. 아래 코드를 이용하면 방향 전환을 수식으로 정의할 수 있다.

```csharp
_dir = (_dir - 1 + 4) % 4;
// 우측으로 90도 회전
_dir = (_dir + 1 + 4) % 4;
// 좌측으로 90도 횐전
```

이러한 방식은 열거형 타입 내의 상태를 변화시키는데 유용하게 사용된다. 

### 바라보는 방향으로 앞으로 이동

바라보는 방향으로 앞으로 이동시키는 로직은 현재의 상태에 따라 다른 좌표 변경이 이루어진다. 위를 보고 있을 때는 y좌표를 1증가시켜주고 아래를 보고 있을 때는 1감소시켜주어야 한다. 오른쪽을 보고 있을 때는 x좌표를 1증가시켜야 하고 왼쪽을 보고 있을 때는 x좌표를 1감소시켜야 한다. 이를 구현하기 위해 **Switch-Case문**을 사용할 수도 있지만 마찬가지로 코드가 길어질 수 있다.

바라보는 방향에 따른 전진에 대한 좌표변화를 배열에 기억시켜 처리하면 간단한 코드로도 구현이 가능하다. 아래 코드에서 frontY는 Dir 타입 기준으로 앞으로 이동할 때의 Y좌표 변화를 의미힌다. 

**즉, 위를 보고 있을 때의 전진은 y좌표로 -1만큼 이동한다는 것이다.**

```csharp
int[] frontY = new int[4] { -1, 0, 1, 0 };
int[] frontX = new int[4] { 0, -1, 0, 1 };

// 목적지에 도착했는지 확인
while (PosY != board.DesY || PosX != board.DesX)
{
		// 1. 현재 바라보는 방향을 기준으로 오른쪽으로 갈 수 있는지 확인.
		if (_board.Tile[PosY + frontY[(_dir - 1 + 4) % 4], PosX + frontX[(_dir - 1 + 4) % 4]] != Board.TileType.Wall) 
	  {
	      // 오른족 방향으로 90도 회전, 앞으로 전진
	      _dir = (_dir - 1 + 4) % 4;
	      PosY = PosY + frontY[_dir];
	      PosX = PosX + frontX[_dir];
	      _movePath.Add(new int[2] { PosY, PosX });
		}
		  // 2. 현재 바라보는 방향으로 앞으로 갈 수 있는지 확인.
	  else if (_board.Tile[PosY + frontY[_dir], PosX + frontX[_dir]] != Board.TileType.Wall)
	  {
				PosY = PosY + frontY[_dir];
				PosX = PosX + frontX[_dir];
				_movePath.Add(new int[2] { PosY, PosX });
		}
	  else
	  {
				// 왼쪽 방향 90도 회전
				_dir = (_dir + 1 + 4) % 4;
		}
}
```