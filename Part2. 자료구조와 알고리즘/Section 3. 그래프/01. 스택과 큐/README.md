# Section 3-1 스택과 큐
## 스택(Stack)

오른손 법칙으로 구현한 이동 로직은 길찾기 알고리즘이라고 부르기에는 부족한 부분들이 많다. 벽이 반드시 있어야하며, 최적화된 경로도 아니기 때문이다. 

범용적인 길찾기 알고리즘을 구현함에 앞서 데이터 구조에 대해 알아본다.

`Stack`은 **LIFO(후임 선출, Last In First Out) 구조**를 가지고 있는 데이터 구조를 의미한다. 주 기능으로는 `Push`, `Pop`, `Peek` 세가지가 있다.

```csharp
Stack<int> stack = new Stack<int>();

stack.Push(101); // [ 101 ]
stack.Push(102); // [ 101, 102 ]
stack.Push(103); // [ 101, 102, 103 ]

int a = stack.Pop(); // [ 101, 102 ] , a = 103 
int b = stack.Peek(); // [ 101, 102 ] , b = 102
```

## 큐(Queue)


`Queue`는 **FIFO(선입 선출, First In First Out) 구조**를 가지고 있는 데이터 구조를 의미한다. 주 기능으로는 `Enqueue`, `Dequeue`, `Peek` 세가지가 있다.

```csharp
Queue<int> queue = new Queue<int>();

queue.Enqueue(101); // [ 101 ]
queue.Enqueue(102); // [ 101, 102 ]
queue.Enqueue(103); // [ 101, 102, 103 ]

int c = queue.Dequeue(); // [ 102, 103 ], c = 101
int d = queue.Dequeue(); // [ 103 ], d = 102
int e = queue.Peek(); // [ 103 ], e = 103
```

💡 **기존 데이터 타입이 있음에도 스택과 큐가 존재하는 이유**

선입선출, 후입선출의 기능은 기존의 배열, 동적 배열, 연결 리스트 등으로도 충분히 구현할 수 있다. 그럼에도 스택과 큐를 따로 정의하여 널리 사용하는 이유는 추상적으로 사용하기에 좋기 때문이다. 예로 개발자들은 의사소통을 할 때 `‘스택 구조로 개발할것이다, 큐 구조로 개발할 것이다’` 라는 말을 전달하면 의미 전달이 쉽다.

배열, 동적 배열, 연결 리스트로 스택과 큐를 구현하기도 한다. 

스택의 경우에는 **동적배열 자료형으로 구현하기 좋을 수 있다.** 마지막 값을 빼오기 때문에 동적배열의 시간 복잡도 상으로 효율이 좋기 때문이다.

반대로 큐는 **동적배열 자료형으로 구현하기에 좋지 않다.** 가장 앞에 있는 데이터가 빠져나가기 때문에 전체 동적배열 원소들을 옮겨야하므로 시간 복잡도가 좋지 않다.
